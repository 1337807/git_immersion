---------------------------------------------------------------------- 
h1. Setup

h2. Goals

* To setup git so that it is ready for work.

h2. Steps

h3. Setup Name and Email

p. If you have never used git before, you need to do some setup first.
Run the following commands so that git knows your name and email.  If
you have git already setup, you can skip down to the line ending
section.

execute:
git config --global user.name "Your Name"
git config -- user.email "your_email@whatever.com"
 
h3. Setup Line Ending Preferences

Also, for Unix/Mac users:

execute:
git config --global core.autocrlf input
git config --global core.safecrlf true

And for Windows users:

execute:
git config --global core.autocrlf true
git config --global core.safecrlf true

---------------------------------------------------------------------- 
h1. More Setup

h2. Goals

* Get the tutorial materials setup and ready to run.

h2. Steps

h3. Get the Tutorial package.

p. Git the tutorial package from either:

* The memory sticks provided in the tutorial
* The URL "http://onestepback.org/download/git_tutorial.zip":http://onestepback.org/download/git_tutorial.zip

h3. Unzip the tuturial

p. The tutorial package should have a main diretory "git_tutorial"
with three sub-directories:

* html -- These html files.  Point your browser to html/index.html
* repos -- Prepackages repos for later use
* work -- An empty working directory.  Create your repos in here.

---------------------------------------------------------------------- 
h1. Create a Project

h3. In an empty directory create the following file:

File: hello.rb
puts "Hello, World"
EOF

h3. Make the first commit

Execute:
git init
=init
git add hello.rb
=add
git commit -m 'First Commit'
=commit

p. You should see ...

Sample:
$ git init
=init
$ git add hello.rb
=add
$ git commit -m 'First Commit'
=commit
EOF

---------------------------------------------------------------------- 
h1. Recording Changes

File: hello.rb
puts "Hello, #{ARGV.first}!"
EOF

h3. Check the status

p. See that get has detected that the file has changed, but it doesn't
know what to do with it yet.

Execute:
!git status

p. (checking the status is a good habit to get into.)

p. Now tell git to stage the changes.  Check the status

Execute:
git add hello.rb
git status

p. The changes are ready to be committed.  If you leave off the -m,
Git will allow you to edit the commit message using your editor.  The
editor is selected from (in order):

* GIT_EDITOR environment variable
* core.editor configuration setting
* VISUAL environment variable
* EDITOR environment variable

p. Mine is set to "emacsclient".

p. So commit now and check the status.

Execute:
-git commit
+git commit -m 'Using ARGV'

p. Using your editor, enter the commit comment "Using ARGV"

p. Finally check the status again.  It should say "nothing to commit
(working directory clean)".

Execute:
!git status

----------------------------------------------------------------------
h1. Changes, not Files

p. Most source control systems work with files.  Git focuses on
changes rather than files.  This lab will attempt to show the
difference.

h3. First Change: Allow a default name

p. Change the file to be:

File: hello.rb
name = ARGV.first || "World"

puts "Hello, #{name}!"
EOF

h3. Add this Change

Execute:
git add hello.rb

h3. Second change: Add a comment

Change hello.rb to be:

File: hello.rb
# Default is "World"
name = ARGV.first || "World"

puts "Hello, #{name}!"
EOF

h3. Check the current status

Execute:
!git status

p. Notice how hello.rb is listed twice in the status.  It has some
changes (the default value for name) ready to be committed.

p. It also has some changes (the added comment) that are unstaged.  If
a commit were to happen right now, only the first change would be
committed.

p. Git tracks changes, not files.

h3. Adding the additional changes

p. Now add the second change to staging area, then run git status.

Execute:
git add .
!git status

p(((((note). <b>Note:</b> We used the current directory ('.') as the
file to add.  This is a really convenient shortcut for adding in all
the changes to the files in the current directory and below.  Since it
adds everything, its a good idea to run the status before doing an
"add .".

p. Both changes have been staged and are ready to be committed.

Execute:
git commit -m 'added default for name'

----------------------------------------------------------------------
h1. History

p. Getting a listing of what changes have been made is the function of
the 'git log' command.

Execute:
git log

p. This dumps a listing of all the commits made to date. You can limit
the number of entries in a number of different ways.  You can also
change the format. Play around with the following:

pre(instructions).
git log --max-count=2
git log --since='5 minutes ago' 
git log --until='5 minutes ago' 
git log --author=<your name>
git log --pretty=oneline

p. See man git-log for all the details.

h3. Getting Fancy

p. Here's what I use to review the changes made in the last week.
I'll add a --author=jim to it I only want to see changes I made.

pre(instructions).
git log --all --pretty=format:"%h %cd %s (%an)" --since='7 days ago'

h3. Other Tools

p. Both <code>gitx</code> (for Macs) and <code>gitk</code> (any
platform) are useful in exploring log history.

---------------------------------------------------------------------- 
h1. Getting Old Versions

p. Going back in history is very easy.  The checkout command will copy
any snapshot from the repository to the working directory.

h3. Get the hashes for previous versions

Execute:
git log --pretty=oneline
=log

p. You should see something like:

Sample:
$ git log --pretty=oneline
=log
EOF

p. Examine the log output and find the hash for the first commit.  Use
that hash code (the first 8 characters is enough) in the command
below.  Then check the contents of the hello.rb file.

Set: hash=hash_for("First Commit")
Execute:
git checkout <hash>
=checkout
cat hello.rb
=cat

p(((((note). *Note:* The commands given here are Unix commands and 
work on both Mac and Linux boxes.  Unfortunately, Windows users will
have to translate to their native commands.  

p(((((note). *Note:* Many commands depend on the hash values in the
repository.  Since your hash values will vary from mine, whenever you
see something like &lt;hash&gt; or &lt;treehash&gt; in the command,
substitute in the proper hash value for your repository.

p. You should see ...

Sample:
$ git checkout <hash>
=checkout
$ cat hello.rb
=cat
EOF

p. You will probably get some complaints about not being on a local
branch.  That's ok for now.  Notice the contents of the hello.rb file
are the original contents.

h3. Return the latest version in the master branch

Execute:
git checkout master
cat hello.rb

p. 'master' is the name of the default branch.  By checking out a branch
by name, you go to the lastest version of that branch.

----------------------------------------------------------------------
h1. Tagging versions

p. Let's call the current version of the hello program version 1 (v1).

h3. Tagging version 1

Execute:
git tag v1

p. Now you can refer to the current version of the program as v1.  

h3. Tagging a previous version

p. Let's tag the second version of our program as v1-beta.  First we need
to checkout the previous version.  Rather than lookup up the hash, we
will use the ^ notation to indicate "the parent of v1".

Execute:
git checkout v1^
cat hello.rb

p. See, this is the version _before_ we added the default value.
Let's make this v1-beta.

Execute:
git tag v1-beta

p. Now try going back and forth between the two tagged versions.

Execute:
git checkout v1
git checkout v1-beta

p. You can see what tags are available using the 'git tag' command.

Execute:
git tag

p. Make sure you are at the head of the master branch before
proceeding to the next lab.

Execute:
git checkout master

----------------------------------------------------------------------
h1. Reverting Local Changes (before committing)

p. Sometimes you have modified a file in your local working directory
and you wish to just revert to what has already been commited.  The
checkout command will handle that.

h3. Change hello.rb

Change hello.rb to have a bad comment.

File: hello.rb
# This is a bad comment.  We want to revert it.
name = ARGV.first || "World"

puts "Hello, #{name}!"
EOF

h3. Run

p. First, check the status.

Execute:
!git status

Now lets go back to the previous version of the file.

Execute:
git checkout hello.rb
!git status
cat hello.rb

p. We are now back to the checked-in version.

---------------------------------------------------------------------- 
h1. Aliases

p. Git status, git add, git commit, and git checkout are such common
commands that it is useful to have abbreviations for them.

h3. Common Aliases

Add the following to the .gitconfig file in your $HOME directory.

file: .gitconfig
[alias]
  co = checkout
  ci = commit
  st = status
  br = branch
  hist = log --pretty=oneline --abbrev-commit --graph --decorate
  type = cat-file -t
  dump = cat-file -p
EOF

p. We've covered checkout, commit and status already.  Now, whenever you
can type 'git co' whereever you used to have to type 'get checkout'.
Likewise with 'git st' for 'git status' and 'git ci' for git commit'.

p. Go ahead and give the new commands a try.

p. By the way, I'll continue to type out the full command in these
instructions, but feel free to use the aliases above.  Also, you
should experiment with adding your own aliases as you go.

h3. Commands to come...

p. We've added a few aliases for command we haven't covered yet. The
'git branch' command will be coming up soon.  And the 'git cat-file'
command is useful for exploring git, which we will see in the next
section.

h3. Shell Aliases

p. If your shell supports aliases or shortcuts, then you can add
aliases at that level too.  Here are the ones I use:

file: .profile
alias gs='git status '
alias ga='git add '
alias gb='git branch '
alias gc='git commit'
alias gd='git diff'
alias go='git checkout '
alias gk='gitk --all&'
alias gx='gitx --all'

alias got='git '
alias get='git '
EOF

p. The 'go' abbreviation for 'git checkout' is particularly nice.  It
allows me to type.

pre(instructions). go <branch>

p. to checkout a particular branch.

p. And yes, I do mistype 'git' as 'get' or 'got' enough to create
aliases for them.
 
----------------------------------------------------------------------
h1. Moving Files
 
h3. Move the hello.rb file into a lib directory.

Execute:
mkdir lib
git mv hello.rb lib
!git status

p. By using git to do the move, we inform git of 2 things 

# That the file @hello.rb@ has been deleted.
# The file @lib/hello.rb@ has been created.

p. Both of these bits of information are immediately staged and ready
to be commited.  The git status command reports that the file has been
moved.

h3. Another way of moving files

p. One of the nice things about git is that you can forget about
source control until the point you are ready to start committing code.
What would happen if we used the operating system command to move the
file instead of the git command?

p. It turns out the following set of commands is identical to what we
just did.  Its a bit more work, but the result is the same.

p(command). We could have done:

pre(instructions). mkdir lib
mv hello.rb lib
git add lib/hello.rb
git rm hello.rb

h3. Commit the new directory

Execute:
git commit -m 'Moved hello.rb to lib'

----------------------------------------------------------------------
h1. More Structure

h3. Now add a Rakefile

File: Rakefile
#!/usr/bin/ruby -wKU

task :default => :run

task :run do
  require 'lib/hello'
end
EOF

p. Add and commit the change.

Execute:
git add .
git commit -m 'Added a Rakefile.'

p. You should be able to use Rake to run your hello program now.

Execute:
rake

----------------------------------------------------------------------
h1. Git Internals: The .git directory 

h3. Object Store

p. Time to do some exploring.  First, from the root of your project
directory...

Execute:
ls .git

p. This is the magic directory where all the git "stuff" is stored.
Let's peek in the objects directory.
 
Execute:
ls .git/objects

p. You should see a bunch of directories with 2 letter names.  The
directory names are the first two letters of the sha1 hash of the
object stored in git.

p. Look in one of the two-letter directories.  You should see some
files with 38 character names.  These are the files that contain the
objects stored in git.  These files are compressed and encoded, so
looking at their contents directly won't be very helpful, but we will
take a closer look in a bit.

h3. Config File

Execute:
cat .git/config

p. This is project specific configuration file.  Config entries in
here will override the config entries in the .gitconfig file in your
home directory, at least for this project.

h3. Branches and Tags

Execute:
ls .git/refs
ls .git/refs/heads
ls .git/refs/tags
cat .git/refs/tags/v1

p. You should recogize the files in the tags subdirectory.  Each file
corresponds to a tag you created with the 'git tag' command earlier.
It's contents is just the hash of the commit tied to the tag.

p. The heads directory is similar, but is used for branches rather
than tags.  We only have one branch at the moment, so all you will see
is master in this directory.

h3. The HEAD File

Execute:
cat .git/HEAD

p. The HEAD file contains a reference to the current branch.  Should
be a reference to master at this point.

----------------------------------------------------------------------
h1. Git Internals: Working directly with Git Objects

p. Now let's use some tools to probe git objects directly.

h3. Finding the Latest Commit

Execute:
git log --max-count=1 --pretty=oneline
=log

p. This should show the latest commit made in the repository.  The
SHA1 hash on your system is probably different that what is on mine,
but you should see something like this.

Sample:
$ git log --max-count=1 --pretty=oneline
=log
EOF

h3. Dumping the Latest Commit

Using the SHA1 hash from the above ...

Set: hash=hash_for("Added a Rakefile")
Execute:
git cat-file -t <hash>
git cat-file -p <hash>
=dump

Here's my output ...

Sample:
$ git cat-file -t <hash>
commit
$ git cat-file -p <hash>
=dump
EOF

p(((((note). *NOTE:* If you defined the 'type' and 'dump' aliases from 
the aliases lab, then you can type 'git type' and 'git dump' rather
than the longer cat-file commands (which I never remember).

p(((((note). *ANOTHER* *NOTE:* You only have to type the first few
letters in a hash.  Git will figure out what you mean.

p. This is the dump of the commit object that is at the head of the
master branch.  It looks a lot like the commit object from the
presentation earlier.

h3. Finding the Tree

p. We can dump the directory tree referenced int he commit.  This
should be a description of the (top level) files in our project (for
that commit).

Set: treehash=hash_in(var['hash'], 'tree')
Execute:
git cat-file -p <treehash>
=treedump

p. Here's what my tree looks like...

Sample:
$ git cat-file -p <treehash>
=treedump
EOF

p. Yep, I see the Rakefile and the lib directory.  Let's dive down
into the lib directory...

Set: libhash=hash_in(var['treehash'], 'lib') 
Execute:
git cat-file -p <libhash>
=libdump

Sample:
$ git cat-file -p <libhash>
=libdump
EOF

p. There's the @hello.rb@ file.  Let's dump that ...

Set: rbhash=hash_in(var['libhash'], 'hello')
Execute:
git cat-file -p <rbhash>
=rbdump

Sample:
$ git cat-file -p <rbhash>
=rbdump
EOF

p. There you have it.  We've dumped commit objects, tree objects and
blob objects directly from the git repository.  That's all that is
there, blobs, trees and commits.

h3. Explore On You Own

p. Explore the git repo manually on your own.  See if you can find the
original hello.rb file from the very first commit by manually
following the SHA1 hash references starting in the latest commit.

----------------------------------------------------------------------
h1. Creating a Branch

p. It's time to do a major rewrite of the hello world functionality.
Since this might take awhile, you want to put these changes into a
separate branch to isolate them from changes in master.

h3. Create a Branch

p. Let's call our new branch 'greet'.

Execute:
git checkout -b greet
!git status

p. Notice that the git status command reports that you are on the
'greet' branch.

h3. Changes for Greet: Add a Greeter class.

File: lib/greeter.rb
class Greeter
  def initialize(who)
    @who = who
  end
  def greet
    "Hello, #{@who}"
  end
end
EOF

Execute:
git add .
git commit -m 'added greeter class'

h3. Changes for Greet: Modify the main program

p. Update the hello.rb file to use greeter

File: lib/hello.rb
require 'greeter'

# Default is World
name = ARGV.first || "World"

greeter = Greeter.new(name)
puts greeter.greet
EOF

Execute:
git add .
git commit -m 'hello uses Greeter'

h3. Changes for Greet: Update the Rakefile

p. Update the Rakefile to use an external ruby process

File: Rakefile
#!/usr/bin/ruby -wKU

task :default => :run

task :run do
  ruby '-Ilib', 'lib/hello.rb'
end
EOF

Execute:
git add .
git commit -m 'Updated Rakefile'

----------------------------------------------------------------------
h1. Navigating Branches

p. You now have two branches in your project:

Execute:
git log --pretty=oneline --decorate --abbrev-commit 

You should see something like:

Sample:
$ git log --pretty=oneline --decorate --abbrev-commit 
1f9a5d2 (HEAD, greet) updated Rakefile
851184d hello uses Greeter
5a8a719 added Greeter class
213276d (origin/master, origin/HEAD, master) added a rakefile
d6fc54a Moved hello.rb to lib
dafefe0 (v1) added default for name
f0948e0 (v1-beta) Using ARGV
aab4381 First Commit
$ 
EOF

h3. Switching Branches

p. Just use the 'git checkout command to switch between branches. 

Execute:
git checkout master
cat lib/hello.rb

p. You are now on the master branch.  Switch back to the greet branch.

Execute:
git checkout greet
cat lib/hello.rb
 
----------------------------------------------------------------------
h1. Changes in Master

h2. Goals

* Learing how to deal with multiple branches with different (and possibly conflicting) changes.

h2. Steps

p. While you were changing the greet branch, someone else decided to
update the master branch.  They added a README.

h3. Update the README file with changes.

File: README
This is the Hello World example from the git tutorial.
EOF

h3. Commit the README changes to master.

Execute:
git checkout master
git add README
git commit -m 'Added README'

----------------------------------------------------------------------
h1. Viewing Diverging Branches

h2. Goals

* Learn how to view diverging branches in a repository.

h2. Steps

h3. View the Current Branches

p. We now have two diverging branches in the repository.  Use the
following log command to view the branches and how they diverge.

Execute:
git log --pretty=oneline --abbrev-commit --graph --decorate --all

p. I get something like this:

Sample:
$ git log --pretty=oneline --abbrev-commit --graph --decorate --all
* a1416cc (greet) Updated Rakefile
* fe1a57b hello uses Greeter
* 40855dc added greeter class
| * ac88530 (HEAD, master) Added README
|/  
* 4057fe3 Added a Rakefile.
* 477c3d0 Moved hello.rb to lib
* 66875dc (v1) added default for name
* 01855a9 (v1-beta) Using ARGV
* e8aaea7 First Commit
EOF

p. Adding the --graph option to git log causes it to draw the commit
tree using simple ASCII characters.  We can see both branches (greet
and master), and that the master branch is the current HEAD.  The
common ancestor to both branches is the "Added a Rakefile" branch.

p. The @--all@ flag makes sure that we see all the branches.  The
default is to show only the current branch.

----------------------------------------------------------------------
h1. Merging

h2. Goals

* Learning who to merge two diverging branches to bring the changes back into a single branch.

h2. Steps

h3. Merge the branches

p. Merging brings the changes in two branches together.  Let's go back
to the greet branch and merge master onto greet.

Execute:
git checkout greet
git merge master
git log --pretty=oneline --decorate --abbrev-commit --graph --all

p. By merging master into your greet branch periodically, you can pick
up any changes to master and keep your changes in greet compatible
with changes in the mainline.

p. However, it does produce ugly commit graphs. Latter we will look at
the option of rebasing rather than merging.

h3. Up Next

p. But first, what if the changes in master conflict with the changes
in greet?

----------------------------------------------------------------------
h1. Creating a Conflict

h2. Goals

* Create a conflicting change in the master branch.

h2. Steps

h3. Switch back to master and create a conflict

p. Switch back to the master branch and make this change:

Execute:
git checkout master

File: lib/hello.rb
# Default is World

puts "What's your name"
my_name = gets.strip

puts "Hello, #{my_name}!"
EOF

Execute:
git add .
git commit -m 'made interactive'

h3. View the Branches

Execute:
git log --pretty=oneline --decorate --abbrev-commit --graph --all

p. I get the following:

Sample:
$ git log --pretty=oneline --decorate --abbrev-commit --graph --all
*   b29584f (greet) Merge branch 'master' into greet
|\  
* | a5e7798 Updated Rakefile
* | ec2a51e hello uses Greeter
* | a672f68 added greeter class
| | * 6b2a404 (HEAD, master) made interactive
| |/  
| * 5ce262a Added README
|/  
* 93e40bd Added a Rakefile.
* 34b8342 Moved hello.rb to lib
* 0705d29 (v1) added default for name
* 91c92a1 (v1-beta) Using ARGV
* 0d9ae0b First Commit
end
EOF

p. Master at commit "Added README" has been merged to the greet
branch, but there is now an additional commit on master that has not
been merged back to greet.

h3. Up Next

p. The latest change in master conflicts with some existing changes in
greet.  Next we will resolve those changes.

----------------------------------------------------------------------
h1. Resolving Conflicts

h2. Goals

* Learn how to handle conflicts during a merge

h2. Steps

h3. Merge master to greet

p. Now go back to the greet branch and try to merge the new master.

Execute:
git checkout greet
!git merge master

p. I get...

Sample:
$ git checkout greet
Switched to branch 'greet'
$ git merge master
Auto-merging lib/hello.rb
CONFLICT (content): Merge conflict in lib/hello.rb
Automatic merge failed; fix conflicts and then commit the result.
EOF

If you open lib/hello.rb, you will see:

file: lib/hello.rb
<<<<<<< HEAD
require 'greeter'

# Default is World
name = ARGV.first || "World"

greeter = Greeter.new(name)
puts greeter.greet
=======
# Default is World

puts "What's your name"
my_name = gets.strip

puts "Hello, #{my_name}!"
>>>>>>> master
EOF

p. The first section is the version on the head of the current branch
(greet).  The second section is the version on the master branch.

h3. Fix the Conflict

p. You need to manually resolve the conflict.  Modify @lib/hello.rb@
to be the following.

File: lib/hello.rb
require 'greeter'

# Default is World

puts "What's your name"
my_name = gets.strip

greeter = Greeter.new(my_name)
puts greeter.greet
EOF

h3. Commit the Conflict Resolution

Execute:
git add lib/hello.rb
git commit -m 'Merged master fixed conflict.'

h3. Advanced Merging

p. git doesn't provide any graphical merge tools, but it will gladly
work with any third party merge tool you wish to use.  See
"http://onestepback.org/index.cgi/Tech/Git/UsingP4MergeWithGit.red":http://onestepback.org/index.cgi/Tech/Git/UsingP4MergeWithGit.red
for a description of using the Perforce merge tool with git.

----------------------------------------------------------------------
h1. Rebasing VS Merging

h2. Goals

* Learn the differences between rebasing and merging.

h2. Discussion

p. Let's explore the differences between merging and rebasing.  In
order to do so, we need to rewind the repository back in time before
the first merge, and then redo the same steps, but using rebasing
rather than merging.

h3. But First, An Aside on the Reset command

p. The reset command can be used to force any branch reference to
point to any commit.  We will use this ability to make master and
greet point to an earlier commit in their history, essentially
rewinding them back in time.

p. Note that the reset command does not change the commit tree in the
repository.  All we are doing is pointing the branch to a different
commit.  The old commit objects are still in the repository, but
unreferenced.  Eventually they will be garbaged collected.

----------------------------------------------------------------------
h1. Reseting the Greet Branch

h2. Goals

* Reset the greet branch to the point before the first merge.

h2. Steps

h3. Reset the greet branch

p. Let's go back in time on the greet branch to the point _before_ we
merged master onto it.  We can *reset* a branch to any commit we want.
Essentially this is modifying the branch pointer to point to anywhere
in the commit tree.

p. In this case we want to back greet up to the point prior to the
merge with master.  We need to find the last commit before the merge.

Execute:
git log --pretty=oneline --abbrev-commit --graph --decorate

I see something like this:

Sample:
$ git log --pretty=oneline --abbrev-commit --graph --decorate
*   266feda (HEAD, greet) Merged master fixed conflict.
|\  
| * 2bd4219 (master) made interactive
* |   f60c7f6 Merge branch 'master' into greet
|\ \  
| |/  
| * b6620b3 Added README
* | 1f9a5d2 updated Rakefile
* | 851184d hello uses Greeter
* | 5a8a719 added Greeter class
|/  
* 213276d added a rakefile
* d6fc54a Moved hello.rb to lib
* dafefe0 (v1) added default for name
* f0948e0 (v1-beta) Using ARGV
* aab4381 First Commit
$ 
EOF

p. That's a bit hard to read, but looking at the data we see that the
"Updated Rakefile" commit was the last commit on the greet branch
before merging.  Let's reset the greet branch to that commit.

Set: hash=hash_for("Updated Rakefile")
Execute:
git reset --hard <hash>

p. Make sure you substitute the proper hash value for "&lt;hash&gt;".
Yours will most certainly be different from the ones listed here.

p(((((note). *NOTE:* Resetting local branches is generally not a
problem.  Reseting publicly shared branches is a bad idea.  (Discuss
why this is a bad idea).

p. The @--hard@ parameter makes sure the working directory is up to
date with the change in the branch.

h3. Check the branch.

p. Look at the log for the greet branch.  We no longer have the merge
commits in its history.

Execute:
git log --pretty=oneline --abbrev-commit --graph --decorate --all

p. I see something like...

Sample:
git log --pretty=oneline --abbrev-commit --graph --decorate --all
* b6e8dd9 (HEAD, greet) Updated Rakefile
* cbd0d9e hello uses Greeter
* eea809d added greeter class
| * 843a23d (master) made interactive
| * 12e9e89 Added README
|/  
* dc8a533 Added a Rakefile.
* 7fab506 Moved hello.rb to lib
* 14f13d4 (v1) added default for name
* 531dd55 (v1-beta) Using ARGV
* 484866c First Commit
EOF

----------------------------------------------------------------------
h1. Reseting the Master Branch

h2. Goals

* Reset the master branch to the point before the conflicting commit.

h3. Reset the master branch

Let's backup the master branch to the point before we added the
conflicting commit.

Execute:
git checkout master
git log --pretty=oneline --abbrev-commit --graph --decorate

Sample:
$ git log --pretty=oneline --abbrev-commit --graph --decorate
* 2bd4219 (HEAD, master) made interactive
* b6620b3 Added README
* 213276d added a rakefile
* d6fc54a Moved hello.rb to lib
* dafefe0 (v1) added default for name
* f0948e0 (v1-beta) Using ARGV
* aab4381 First Commit
EOF

p. Let's backup to the 'Added README' commit.

Set: hash=hash_for("Added README")
Execute:
git reset --hard <hash>
git log --pretty=oneline --abbrev-commit --graph --decorate --all

p. Review the log.  It should look like the repository has been wound
back in time to the point before we merged anything.

p. I see ...

Sample:
$ git log --pretty=oneline --abbrev-commit --graph --decorate --all
* 219e23c (greet) Updated Rakefile
* 41444b5 hello uses Greeter
* 98b4456 added greeter class
| * 6912532 (HEAD, master) Added README
|/  
* 606942b Added a Rakefile.
* a724ded Moved hello.rb to lib
* 7dcacae (v1) added default for name
* 8aec63b (v1-beta) Using ARGV
* 60e17f8 First Commit
EOF

----------------------------------------------------------------------
h1. Rebasing

h2. Goals

* Use the rebase command rather than the merge command.

h2. Steps

p. Ok, we are back in time before the merge and we want to get the
changes in master into our greet branch.

Execute:
git checkout greet
git rebase master
git log --pretty=oneline --abbrev-commit --graph --decorate

p. I got this:

Sample:
$ go greet
Switched to branch 'greet'
$
$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: added Greeter class
Applying: hello uses Greeter
Applying: updated Rakefile
$
$ git log --pretty=oneline --abbrev-commit --graph --decorate
* 2959c66 (HEAD, greet) Updated Rakefile
* 692cd13 hello uses Greeter
* 19b340a added greeter class
* f33db46 (master) Added README
* 166ee19 Added a Rakefile.
* 22176de Moved hello.rb to lib
* f9ee428 (v1) added default for name
* e0d38e1 (v1-beta) Using ARGV
* 60beb94 First Commit
EOF

h3. Merge VS Rebase

p. The final result of the rebase is very similar to the merge.  The
greet branch now contains all of its changes, as well as all the
changes from the master branch.  However, the commit tree is quite
different.  The commit tree for the greet branch has been rewritten so
that the master branch is a part of the commit history.  This leaves
the chain of commits linear and much easier to read.

h3. When to Rebase, When to Merge?

p. Don't use rebase ...

# If the branch is public and shared with others.  Writing publicly shared branches will tend to screw up other members of the team.
# When the _exact_ history of the commit branch is important (since rebase rewrites the commit history).

p. Given the above guidelines, I tend to use rebase for short-lived,
local branches and merge for branches in the public repository.

----------------------------------------------------------------------
h1. Merging Back to Master

h2. Goals

* We've kept our greet branch up to date with master (via rebase), now lets merge the greet changes back into the master branch.

h2. Steps

h3 Merge greet into master

Execute:
git checkout master
git merge greet

p. Here's what I saw:

Sample:
$ git checkout master
Switched to branch 'master'
$
$ git merge greet
Updating b6620b3..de35373
Fast-forward
 Rakefile       |    2 +-
 lib/greeter.rb |    8 ++++++++
 lib/hello.rb   |    5 ++++-
 3 files changed, 13 insertions(+), 2 deletions(-)
 create mode 100644 lib/greeter.rb
EOF
 
p. Because the head of master is a direct ancestor of the head of the
greet branch, git is able to do a fast forward merge.  When
fast-forwarding, the branch pointer is simply moved forward to point
to same commit as the greeter branch.

p. There will never be conflicts in a fast forward merge.

h3. Review the logs

Execute:
git log --pretty=oneline --abbrev-commit --graph --decorate

Sample:
$ git log --pretty=oneline --abbrev-commit --graph --decorate
* fd8c01b (HEAD, master, greet) Updated Rakefile
* 59c99fd hello uses Greeter
* 7d8c072 added greeter class
* 8050d82 Added README
* 4f07f29 Added a Rakefile.
* 2ff84c5 Moved hello.rb to lib
* e06c9ff (v1) added default for name
* d92e8fe (v1-beta) Using ARGV
* f34f545 First Commit
EOF

p. The greet and master branches are now identical.

----------------------------------------------------------------------
h1. Cloning Repositories

h2. Goals

* Learn how to make copies of repositories.

h2. Steps

h3. Create a clone of the hello repository

p. Go to the working directory and make a clone of your hello
repository.

Execute:
cd ..
pwd
# (you should be in the 'work' directory now) 
ls
# (you should see the 'hello' repository)  
git clone hello cloned_hello
ls
# (you should now see the 'cloned_hello' repository as well) 

p. Here's what I saw ...
 
Sample:
$ cd ..
$ pwd
/Users/jim/Documents/Presentations/GitTutorial/dist/work
$ ls
hello
$ git clone hello cloned_hello
Initialized empty Git repository in /Users/jim/Documents/Presentations/GitTutorial/dist/work/cloned_hello/.git/
$ ls
cloned_hello	hello
EOF

----------------------------------------------------------------------
h1. Review the Cloned Repository

h2. Goals

* Learn about branches on remote repositories.

h3. Look at the cloned repository

p. Let's take a look at the cloned repository.

Execute:
cd cloned_hello
git log --pretty=oneline --abbrev-commit --graph --decorate --all

p. Here's what I saw ...
 
Sample:
$ cd cloned_hello/
$ git log --pretty=oneline --abbrev-commit --graph --decorate --all
* 53bb25c (HEAD, origin/master, origin/greet, origin/HEAD, master) Updated Rakefile
* 31f6fc0 hello uses Greeter
* 080697b added greeter class
* adde071 Added README
* d19231f Added a Rakefile.
* dfcfb9a Moved hello.rb to lib
* 10ddda2 (v1) added default for name
* 2f189a9 (v1-beta) Using ARGV
* 0e63dc3 First Commit
EOF

h3. Remote branches

p. This is almost the same as the original hello repository.  However,
not the list of branches on the "Updated Rakefile" line.  You have a
*master* branch, but you also have number of strangely named branches
(*origin/master*, *origin/greet* and *origin/HEAD*).  We'll talk about
them in a bit.

----------------------------------------------------------------------
h1. What is Origin?

h2. Goals

* Learn about naming remote repositories.

h2. Steps

Execute:
git remote

Sample:
$ git remote
origin
EOF

p. We see that the cloned repository knows about a remote repository
named origin.  Let's see if we can get more information about origin:

Execute:
git remote show origin 

p. This should look like

Sample:
$ git remote show origin
* remote origin
  Fetch URL: /Users/jim/Documents/Presentations/git_immersion/auto/hello
  Push  URL: /Users/jim/Documents/Presentations/git_immersion/auto/hello
  HEAD branch (remote HEAD is ambiguous, may be one of the following):
    greet
    master
  Remote branches:
    greet  tracked
    master tracked
  Local branch configured for 'git pull':
    master merges with remote master
  Local ref configured for 'git push':
    master pushes to master (up to date)
EOF

p. Now we see that the remote repository origin is simply the original
*hello* repository.  There is nothing particularly special about the
name "origin", however the convention is to use the name 'origin' for
the primary centralized repository (if there is one).

----------------------------------------------------------------------
h1. Remote Branches

h2. Goals

* Learn about local VS remote branches

h2. Steps

p. Let's look at the branches available in our cloned repository.

Execute:
git branch

p. You should get ...

Sample:
$ git branch
* master
EOF

p. That's it, only the master branch is listed.  Where is the greet
branch?  The *git* *branch* command only lists the local branches by
default.

h3. List Remote Branches

p. Try this to see all the branches:

Execute:
git branch -a

p. You should get ...

Sample:
$ git branch
* master
  remotes/origin/HEAD -> origin/master
  remotes/origin/greet
  remotes/origin/master
EOF

p. Git has all the commits from the original reposistory, but branches
in the remote repository are not treated as local branches here.  If
we want our own *greet* branch, we need to create it ourselves. We
will see how to do that in a minute.

----------------------------------------------------------------------
h1. Change the Original Repository

h2. Goals

* Make some changes to the original repository so we can try to pull the changes

h2. Steps

h3. Make a change in the original *hello* repository

Execute:
cd ../hello
+pwd
# (You should be in the original hello repository now)

p. Make the following changes to README:

File: README
This is the Hello World example from the git tutorial.
(changed in original)
EOF

p. Now add and commit this change

Execute:
git add README
git commit -m 'Changed REAME in original repo'

h3. Up Next

p. The original repository now has later changes that are not in the
cloned version.  Next we will pull those changes across to the cloned
repository.

----------------------------------------------------------------------
h1. Fetching Changes

h2. Goals

* Learn how to pull changes from a remote repository.

h2. Steps

Execute:
cd ../cloned_hello
+pwd
git fetch

p. You should see ...

Sample:
$ git fetch
remote: Counting objects: 5, done.        
remote: Compressing objects: 100% (3/3), done.        
remote: Total 3 (delta 0), reused 0 (delta 0)        
Unpacking objects: 100% (3/3), done.
From /Users/jim/Documents/Presentations/git_immersion/auto/hello
   1a7c8c1..82d92b3  master     -> origin/master
EOF

p. At this point the repository has all the commits from the original
repository.  However, they have not been merged into the local master
branch.

h3. Check the README

Execute:
cat README

Sample:
$ cat README
This is the Hello World example from the git tutorial.
EOF

p. See, no changes.

----------------------------------------------------------------------
h1. Merging Pulled Changes

h2. Goals

* Learn to get the pulled changes into the current branch and working directory.

h2. Steps

h3. Merge the fetched changes into local master

Execute:
git merge origin/master

Sample:
$ git merge origin/master
Updating 1a7c8c1..82d92b3
Fast-forward
 README |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)
EOF

h3. Check the README again

p. We should see the changes now.

Execute:
cat README

Sample:
$ cat README
This is the Hello World example from the git tutorial.
(changed in original)
EOF

p. There's the changes.


----------------------------------------------------------------------
h1. Pulling Changes

h2. Goals

* Learn that 'git pull' is equivalent to a 'git fetch' followed by a merge.

h2. Discussion

p. We're not going to go through the process of creating another
change and pulling it again, but we do want you to know that doing:

pre(instructions). git pull

is indeed equivalent to the two step

pre(instructions). git fetch
git merge origin/master

----------------------------------------------------------------------




































----------------------------------------------------------------------
h1. Local Branches

TBD

----------------------------------------------------------------------
h1. Added a Tracking Branch

 (NOTE: Consider moving this section after the bare repository)

h2. Goals

* Learn how to add a local branch that tracks a remote branch.

h2. Steps

p. The branches starting with remotes/origin are branches from the
original repo.  Notice that you don't have a branch called greet
anymore, but it knows that the original repo had a greet branch.

h3. Add a local branch that tracks a remote branch.

Execute:
git branch --track greet origin/greet
git branch -a
git log --pretty=oneline --abbrev-commit --graph --decorate -n1

Sample:
$ git branch --track greet origin/greet
Branch greet set up to track remote branch greet from origin.
$ git branch -a
  greet
* master
  remotes/origin/HEAD -> origin/master
  remotes/origin/greet
  remotes/origin/master
$ git log --pretty=oneline --abbrev-commit --graph --decorate -n1
* de35373 (HEAD, origin/master, origin/greet, origin/HEAD, master, greet) updated Rakefile
$ 
EOF

p. We can now see the greet branch in the branch list and in the log.

----------------------------------------------------------------------
h1. Pulling changes

Switch back to the original repository and add a line to the readme.

Execute:
cd ../hello
+pwd
# (You should be in the original hello repository)

p. Change the README file

File: README
This is the Hello World example from the git tutorial.
(Changed in the original)
EOF

p. Commit the change

Execute:
git add README
git commit -m 'Updated README'

p. Now switch back to the cloned directory

Execute:
cd ../cloned_hello
+pwd
# (You should be in the cloned hello repository)
ls

p. We see the changes to README are not here yet.

h3. Fetch the Changes

Execute:
git fetch origin
cat README

Sample:
$ git fetch origin
remote: Counting objects: 5, done.        
remote: Compressing objects: 100% (3/3), done.        
remote: Total 3 (delta 0), reused 0 (delta 0)        
Unpacking objects: 100% (3/3), done.
From /Users/jim/Documents/Presentations/GitTutorial/dist/work/hello
   de35373..33e5af1  master     -> origin/master
$ cat README
This is the Hello World example from the git tutorial.
$ 
EOF

p. The changes have been copied into the repository, but have not yet
been moved into the working directory.  We get the changes by merging
the changes in the remote branch into master.

Execute:
git merge origin/master

h3. Pulling

The fetch/merge commands can be done in one operation with pull.

Execute:
git pull origin

----------------------------------------------------------------------
h1. Bare Repositories

Bare repositories (without working directories) are usually used for
sharing).

h3. Create a bare repository.

Execute:
cd ..
+pwd
# (You should be in the work directory)
git clone --bare hello hello.git
git ls hello.git

Sample:
$ git clone --bare hello hello.git
Initialized empty Git repository in /Users/jim/Documents/Presentations/GitTutorial/dist/work/hello.git/
$ ls 
cloned_hello	hello		hello.git
$ ls hello.git/
HEAD		config		hooks		objects		refs
branches	description	info		packed-refs
EOF

p. The convention is that repositories ending in '.git' are bare
repositories.  We can see that there is no working directory in the
hello.git repo.  Essentially it is nothing but the .git directory of a
non-bare repo.

----------------------------------------------------------------------
h1. Adding a Remote Repository

p. Let's add the hello.git repo to our original repo.

Execute:
cd hello
+pwd
# (You should be in the original repository)
git remote add shared ../hello.git

----------------------------------------------------------------------
h1. Pushing a Change

p. Edit the README and commit it

File: README
This is the Hello World example from the git tutorial.
(Changed in the original and pushed to shared)
EOF

Execute:
git checkout master
git add README
git commit -m 'added shared comment to readme'

p. Now push the change to the shared repo.

Execute:
git push shared master

Sample:
$ git push shared master
Counting objects: 5, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 363 bytes, done.
Total 3 (delta 1), reused 0 (delta 0)
Unpacking objects: 100% (3/3), done.
To ../hello.git
   33e5af1..b044021  master -> master
$
EOF

p(((((note). *NOTE:* We had to explicitly name the branch master that
we were pushing.  It is possible to set it up automatically, but I
_never_ remember the commands to do that.  Check out the "Git Remote
Branch" gem for easy management of remote branches.

----------------------------------------------------------------------
h1. Pulling Shared Changes

p. Quick hop over to the clone repository and lets pull down the
changes just pushed to the shared repo.

Execute:
cd ../cloned_hello
+pwd
# (You should be in the cloned repository)
git remote add shared ../hello.git
git branch --track shared master
git pull shared master
cat README

----------------------------------------------------------------------
h1. Hosting your Git Repositories

p. There are many ways to share git repositories over the network.
Here is a quick and dirty way.

h3. Start up the git server

Execute:
# (From the work directory)
git daemon --verbose --export-all --base-path=.

p. Now, in a separate terminal window, go to your work directory

Execute:
# (From the work directory) 
git clone git:localhost/hello.git network_hello
cd network_hello
ls

p. You should see a copy of hello project.

h3. Pushing to the Git Daemon

p. If you want to push to the git daemon repository, add
@--enable=receive-pack@ to the git daemon command.  Be careful because
there is not authentication on this server, anyone could push to your
repository.

----------------------------------------------------------------------
h1. Sharing Repos

p. See if your neighbor is running the git daemon.  Exchange IP
addresses and see if you can pull from each other's repositories.

p(((((note). *NOTE:* The gitjour gem is really useful in sharing
ad-hoc repositories.

----------------------------------------------------------------------
h1. Advanced / Future Topics

p. Here are some topics you might want to research on your own:

* Reverting Committed Changes
* Cross OS Line Endings
* Remote Servers
* Protocols
* SSH Setup
* Remote Branch Management (git bisect)
* Finding Buggy Commits
* Workflows
* Non-command line tools (gitx, gitk, magit)
* Working with GitHub
